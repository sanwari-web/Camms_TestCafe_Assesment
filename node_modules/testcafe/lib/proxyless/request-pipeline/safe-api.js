"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.safeContinueRequest = exports.safeFulfillRequest = exports.safeContinueResponse = void 0;
const debug_loggers_1 = require("../../utils/debug-loggers");
const cdp_1 = require("../utils/cdp");
const INVALID_INTERCEPTED_RESPONSE_ERROR_MSG = 'Invalid InterceptionId.';
// In some cases (a request was aborted, any page that initiated the request doesn't exist, etc.)
// Chrome Debug Protocol doesn't allow to continue request pipeline
// and raises the "Invalid InterceptionId" error.
// We use the simplest way to fix it - omit such an error.
async function safeContinueResponse(client, data) {
    const isPausedEvent = (0, cdp_1.isRequestPausedEvent)(data);
    try {
        const param = isPausedEvent
            ? { requestId: data.requestId }
            : data;
        await client.Fetch.continueResponse(param);
    }
    catch (err) {
        if (err.message === INVALID_INTERCEPTED_RESPONSE_ERROR_MSG)
            return;
        const formatter = isPausedEvent ? '%r' : '%s';
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.continueResponse. Unhandled error %s during processing ${formatter}`, err, data);
        throw err;
    }
}
exports.safeContinueResponse = safeContinueResponse;
async function safeFulfillRequest(client, fulfillInfo) {
    try {
        await client.Fetch.fulfillRequest(fulfillInfo);
    }
    catch (err) {
        if (err.message === INVALID_INTERCEPTED_RESPONSE_ERROR_MSG)
            return;
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.fulfillRequest. Unhandled error %s during processing %s`, err, fulfillInfo.requestId);
        throw err;
    }
}
exports.safeFulfillRequest = safeFulfillRequest;
async function safeContinueRequest(client, event) {
    try {
        await client.Fetch.continueRequest({ requestId: event.requestId });
    }
    catch (err) {
        if (err.message === INVALID_INTERCEPTED_RESPONSE_ERROR_MSG)
            return;
        (0, debug_loggers_1.requestPipelineLogger)(`Fetch.continueRequest. Unhandled error %s during processing %r`, err, event);
        throw err;
    }
}
exports.safeContinueRequest = safeContinueRequest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2FmZS1hcGkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcHJveHlsZXNzL3JlcXVlc3QtcGlwZWxpbmUvc2FmZS1hcGkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EsNkRBQWtFO0FBS2xFLHNDQUFvRDtBQUVwRCxNQUFNLHNDQUFzQyxHQUFHLHlCQUF5QixDQUFDO0FBRXpFLGlHQUFpRztBQUNqRyxtRUFBbUU7QUFDbkUsaURBQWlEO0FBQ2pELDBEQUEwRDtBQUVuRCxLQUFLLFVBQVUsb0JBQW9CLENBQUUsTUFBbUIsRUFBRSxJQUFrRDtJQUMvRyxNQUFNLGFBQWEsR0FBRyxJQUFBLDBCQUFvQixFQUFDLElBQUksQ0FBQyxDQUFDO0lBRWpELElBQUk7UUFDQSxNQUFNLEtBQUssR0FBRyxhQUFhO1lBQ3ZCLENBQUMsQ0FBQyxFQUFFLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQy9CLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFWCxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDOUM7SUFDRCxPQUFPLEdBQVEsRUFBRTtRQUNiLElBQUksR0FBRyxDQUFDLE9BQU8sS0FBSyxzQ0FBc0M7WUFDdEQsT0FBTztRQUVYLE1BQU0sU0FBUyxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7UUFFOUMsSUFBQSxxQ0FBcUIsRUFBQyxnRUFBZ0UsU0FBUyxFQUFFLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRTlHLE1BQU0sR0FBRyxDQUFDO0tBQ2I7QUFDTCxDQUFDO0FBcEJELG9EQW9CQztBQUVNLEtBQUssVUFBVSxrQkFBa0IsQ0FBRSxNQUFtQixFQUFFLFdBQWtDO0lBQzdGLElBQUk7UUFDQSxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0tBQ2xEO0lBQ0QsT0FBTyxHQUFRLEVBQUU7UUFDYixJQUFJLEdBQUcsQ0FBQyxPQUFPLEtBQUssc0NBQXNDO1lBQ3RELE9BQU87UUFFWCxJQUFBLHFDQUFxQixFQUFDLCtEQUErRCxFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFbkgsTUFBTSxHQUFHLENBQUM7S0FDYjtBQUNMLENBQUM7QUFaRCxnREFZQztBQUVNLEtBQUssVUFBVSxtQkFBbUIsQ0FBRSxNQUFtQixFQUFFLEtBQXlCO0lBQ3JGLElBQUk7UUFDQSxNQUFNLE1BQU0sQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFDLEVBQUUsU0FBUyxFQUFFLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0tBQ3RFO0lBQ0QsT0FBTyxHQUFRLEVBQUU7UUFDYixJQUFJLEdBQUcsQ0FBQyxPQUFPLEtBQUssc0NBQXNDO1lBQ3RELE9BQU87UUFFWCxJQUFBLHFDQUFxQixFQUFDLGdFQUFnRSxFQUFFLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztRQUVwRyxNQUFNLEdBQUcsQ0FBQztLQUNiO0FBQ0wsQ0FBQztBQVpELGtEQVlDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUHJvdG9jb2xBcGkgfSBmcm9tICdjaHJvbWUtcmVtb3RlLWludGVyZmFjZSc7XG5pbXBvcnQgeyByZXF1ZXN0UGlwZWxpbmVMb2dnZXIgfSBmcm9tICcuLi8uLi91dGlscy9kZWJ1Zy1sb2dnZXJzJztcbmltcG9ydCBQcm90b2NvbCBmcm9tICdkZXZ0b29scy1wcm90b2NvbCc7XG5pbXBvcnQgUmVxdWVzdFBhdXNlZEV2ZW50ID0gUHJvdG9jb2wuRmV0Y2guUmVxdWVzdFBhdXNlZEV2ZW50O1xuaW1wb3J0IEZ1bGZpbGxSZXF1ZXN0UmVxdWVzdCA9IFByb3RvY29sLkZldGNoLkZ1bGZpbGxSZXF1ZXN0UmVxdWVzdDtcbmltcG9ydCBDb250aW51ZVJlc3BvbnNlUmVxdWVzdCA9IFByb3RvY29sLkZldGNoLkNvbnRpbnVlUmVzcG9uc2VSZXF1ZXN0O1xuaW1wb3J0IHsgaXNSZXF1ZXN0UGF1c2VkRXZlbnQgfSBmcm9tICcuLi91dGlscy9jZHAnO1xuXG5jb25zdCBJTlZBTElEX0lOVEVSQ0VQVEVEX1JFU1BPTlNFX0VSUk9SX01TRyA9ICdJbnZhbGlkIEludGVyY2VwdGlvbklkLic7XG5cbi8vIEluIHNvbWUgY2FzZXMgKGEgcmVxdWVzdCB3YXMgYWJvcnRlZCwgYW55IHBhZ2UgdGhhdCBpbml0aWF0ZWQgdGhlIHJlcXVlc3QgZG9lc24ndCBleGlzdCwgZXRjLilcbi8vIENocm9tZSBEZWJ1ZyBQcm90b2NvbCBkb2Vzbid0IGFsbG93IHRvIGNvbnRpbnVlIHJlcXVlc3QgcGlwZWxpbmVcbi8vIGFuZCByYWlzZXMgdGhlIFwiSW52YWxpZCBJbnRlcmNlcHRpb25JZFwiIGVycm9yLlxuLy8gV2UgdXNlIHRoZSBzaW1wbGVzdCB3YXkgdG8gZml4IGl0IC0gb21pdCBzdWNoIGFuIGVycm9yLlxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FmZUNvbnRpbnVlUmVzcG9uc2UgKGNsaWVudDogUHJvdG9jb2xBcGksIGRhdGE6IFJlcXVlc3RQYXVzZWRFdmVudCB8IENvbnRpbnVlUmVzcG9uc2VSZXF1ZXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgaXNQYXVzZWRFdmVudCA9IGlzUmVxdWVzdFBhdXNlZEV2ZW50KGRhdGEpO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSBpc1BhdXNlZEV2ZW50XG4gICAgICAgICAgICA/IHsgcmVxdWVzdElkOiBkYXRhLnJlcXVlc3RJZCB9XG4gICAgICAgICAgICA6IGRhdGE7XG5cbiAgICAgICAgYXdhaXQgY2xpZW50LkZldGNoLmNvbnRpbnVlUmVzcG9uc2UocGFyYW0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBJTlZBTElEX0lOVEVSQ0VQVEVEX1JFU1BPTlNFX0VSUk9SX01TRylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBpc1BhdXNlZEV2ZW50ID8gJyVyJyA6ICclcyc7XG5cbiAgICAgICAgcmVxdWVzdFBpcGVsaW5lTG9nZ2VyKGBGZXRjaC5jb250aW51ZVJlc3BvbnNlLiBVbmhhbmRsZWQgZXJyb3IgJXMgZHVyaW5nIHByb2Nlc3NpbmcgJHtmb3JtYXR0ZXJ9YCwgZXJyLCBkYXRhKTtcblxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2FmZUZ1bGZpbGxSZXF1ZXN0IChjbGllbnQ6IFByb3RvY29sQXBpLCBmdWxmaWxsSW5mbzogRnVsZmlsbFJlcXVlc3RSZXF1ZXN0KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LkZldGNoLmZ1bGZpbGxSZXF1ZXN0KGZ1bGZpbGxJbmZvKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gSU5WQUxJRF9JTlRFUkNFUFRFRF9SRVNQT05TRV9FUlJPUl9NU0cpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgcmVxdWVzdFBpcGVsaW5lTG9nZ2VyKGBGZXRjaC5mdWxmaWxsUmVxdWVzdC4gVW5oYW5kbGVkIGVycm9yICVzIGR1cmluZyBwcm9jZXNzaW5nICVzYCwgZXJyLCBmdWxmaWxsSW5mby5yZXF1ZXN0SWQpO1xuXG4gICAgICAgIHRocm93IGVycjtcbiAgICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYWZlQ29udGludWVSZXF1ZXN0IChjbGllbnQ6IFByb3RvY29sQXBpLCBldmVudDogUmVxdWVzdFBhdXNlZEV2ZW50KTogUHJvbWlzZTx2b2lkPiB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgY2xpZW50LkZldGNoLmNvbnRpbnVlUmVxdWVzdCh7IHJlcXVlc3RJZDogZXZlbnQucmVxdWVzdElkIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyOiBhbnkpIHtcbiAgICAgICAgaWYgKGVyci5tZXNzYWdlID09PSBJTlZBTElEX0lOVEVSQ0VQVEVEX1JFU1BPTlNFX0VSUk9SX01TRylcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICByZXF1ZXN0UGlwZWxpbmVMb2dnZXIoYEZldGNoLmNvbnRpbnVlUmVxdWVzdC4gVW5oYW5kbGVkIGVycm9yICVzIGR1cmluZyBwcm9jZXNzaW5nICVyYCwgZXJyLCBldmVudCk7XG5cbiAgICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbn1cbiJdfQ==